// Started: 14.02.2022 17:20
// Changed: 05.02.2023


/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "stm32l031xx.h"
#include <string.h>
#include <stdlib.h>

#include "syst_clock.h"
#include "gpio.h"
#include "delay.h"
#include "i2c.h"
#include "lpuart.h"
#include "bme280.h"
#include "bc66.h"
#include "rtc.h"

//////////////////////////////
#define START_DEV			0
#define GET_VBAT_RSSI		1
#define WAIT_CEREG			2
#define SEND_REPORT			3
#define GO_TO_STOP			4
#define ERROR_PWR_ON		10
#define ERROR_BATTERY		11
#define ERROR_WAIT_CEREG	12
// #define ERROR_CBC		13
#define ERROR_QENG			14
#define ERROR_QIOPEN		15
#define ERROR_QISEND		16
///////////////////////////////

#define WORK_PERIOD		3599    // рабочий период - интервал в секундах между отправками на сервер.
#define CEREG_ATTEMPTS	3       // число попыток зарегистрироваться в сети
#define QIOPEN_ATTEMPTS	3       // число попыток подключится к серверу

extern char LPUART1_rx_buffer[];
extern volatile uint8_t LPUART1_rx_char_cnt;

uint8_t state;					// Текущее состояние машины состояний
uint8_t cereg_count;			// Счётчик попыток зарегистрироваться в сети

int16_t  T;                		// Температура
uint32_t P;                		// Давление
uint32_t H;                		// Влажность

char T_for_print[5];      		// температура для отправки на сервер
char T_for_print_tmp[5];  		// для преобразования температуры в ascii
char P_for_print[5];      		// давление для отправки на сервер
char H_for_print[5];      		// влажность для отправки на сервер

char V_batt[5];           		// напряжение батарейки для отправки на сервер
char RSSI_level[5];      		 // уровень сигнала сети для отправки на сервер

char report_text[125];
char report_text_len[3];

char *write_API_key = "Your-Write-API-key";		// Вставте здесь свой Write API Key для Thingspeak
char *my_server     = "api.thingspeak.com";		// 184.106.153.149
char *my_port       = "80";						// thingspeak порт


int main()
{
    state = START_DEV;
    cereg_count = CEREG_ATTEMPTS;		// Количество попыток зарегистрироваться в сети

    // Инициализация рабочих частот
    // setHSIClock32M();				// Для использования HSI16/4->PLL раскомментируйте эту строку
	// setHSIClock16M();				// Для использования HSI16 раскомментируйте эту строку
    // Если две строки выше закомментированны, то используется MSI 2.097 MHz

    // RCC->CFGR |= RCC_CFGR_STOPWUCK;	// установ бита STOPWUCK для выбора HSI16 после возврата из Stop
    RCC->CFGR &= ~RCC_CFGR_STOPWUCK;	// сброс бита STOPWUCK для выбора MSI после возврата из Stop

    SystemCoreClockUpdate();
	SysTick_Config(SystemCoreClock/1000); // частота прерываний 1000 Гц, тик=1ms

	initGPIOA();
	initI2C();
	initRTC();							// LSE запускается здесь, он нужен и для LPUART1
	LPUART1_init(9600);

	NVIC_SetPriority(LPUART1_IRQn, 0);

	NVIC_EnableIRQ(LPUART1_IRQn);

	__enable_irq();

	// 2.5 секунды чтобы нажать "Connect to the target" в ST-LINK
	for (uint8_t i=0; i<5; i++)
	{
		GPIOA->BSRR = GPIO_BSRR_BS_4;	// LED on
		delay(200);
		GPIOA->BSRR = GPIO_BSRR_BR_4;	// LED off
		delay(300);
	}


	//----------------------- Reset BME280 -------------------------------------
	if (BME280_reset())
	{
		//
	}
	delay(10); //						2 ms - Start-up time in BME280 datasheet

	//----------------------- Set parameters for measurement -------------------
	if (BME280_set_acquisition(OVER_1x, OVER_1x, OVER_1x, BME280_FORCED_MODE,
			              BME280_STANDBY_500us, BME280_IIR_OFF, BME280_SPI_OFF))
	{
		//
	}



	initWakeup(WORK_PERIOD);



	//----------------------- Main cycle ---------------------------------------
	while (1)
	{
		switch(state)
		{
		case START_DEV:

		// измерение температуры, давления, влажности
		if (BME280_measure(&T, &P, &H))
		{
			T = 0;
			P = 0;
			H = 0;
		}

		// Температура для отправки на сервер
		memset(T_for_print, 0x00, sizeof(T_for_print));
		if (T < 0x0000)
		{
			T = abs(T);                   // абсолютное значение
			strcat (T_for_print, "-");    // знак минус для отрицательных температур
		}
		else
		{
			// strcat (T_for_print, "+"); // знак плюс для положительных температур
		}
		// целая часть температуры
		uint16_t quotient_part_T = 0;
		quotient_part_T = (T / 100);
		memset(T_for_print_tmp, 0x00, sizeof(T_for_print_tmp));
		utoa(quotient_part_T, T_for_print_tmp, 10);
		strcat (T_for_print, T_for_print_tmp);
		// разделитель целой и дробной части - точка
		strcat (T_for_print, ".");
		// дробная часть температуры
		uint16_t remainder_part_T = 0;
		remainder_part_T = (T % 100);
		if (remainder_part_T < 10)
			{
				strcat (T_for_print, "0");
			}
		memset(T_for_print_tmp, 0x00, sizeof(T_for_print_tmp));
		utoa(remainder_part_T, T_for_print_tmp, 10);
		strcat (T_for_print, T_for_print_tmp);

		// Давление для отправки на сервер
		memset(P_for_print, 0x00, sizeof(P_for_print));
		utoa(P, P_for_print, 10);

		// Влажность для отправки на сервер
		memset(H_for_print, 0x00, sizeof(H_for_print));
		utoa(H, H_for_print, 10);


		if (!pwr_on_BC66(50))			// включение BC66
		{
			state = ERROR_PWR_ON;
			break;
		}

		else if (!at_qsclk())			// отключение сна BC66
		{
			state = ERROR_PWR_ON;
			break;
		}

		else if (!at_cpin())			// проверка наличия SIM карты
		{
			state = ERROR_PWR_ON;
			break;
		}

		state = WAIT_CEREG;
		break;							// для case START_DEV

			case WAIT_CEREG:

			for (uint8_t i=0; i<250; i++)		// ожидание регистрации в сети 250*0.2 = 50 секунд
			{
				GPIOA->ODR ^= (1 << 4);			// toggle led on PA4

				if (at_cereg())
				{
					state=GET_VBAT_RSSI;		// зарегистрировались
					break;
				}
				else
				{
					if (wait_for_pwr_off(1))	// проверка, не выключился ли модуль?
					{
						state=ERROR_BATTERY;	// да, модуль выключился при регистрации в сети (села батарейка)
						break;
					}
				state=ERROR_WAIT_CEREG;			// не зарегистрировались
				}
			}

			cereg_count--;

			if ((state==ERROR_WAIT_CEREG) && (cereg_count > 0))
			{
				pwr_off_BC66();					// выключение BC66 (до 25 секунд ожидания)
				state = START_DEV;				// попробовать зарегистрироваться ещё раз
				break;
			}

			cereg_count = CEREG_ATTEMPTS;		// число попыток зарегистрироваться в сети после просыпания

			break;								// для case WAIT_CEREG


			case GET_VBAT_RSSI:

				// задержка для стабилизации напряжения после регистрации в сети
				// при слабом сигнале (больших токах) практически не помогает
				delay(3000);

				// Определим напряжение батарейки
				// АТ-команда для измерения напряжения батарейки: AT+CBC<CR>
				// Ответ BC55 на команду: CR><LF>+CBC: 0,0,3280<CR><LF><CR><LF>OK<CR><LF>
				at_cbc();
				memset(V_batt, 0x00, sizeof(V_batt));

				if (LPUART1_wait_for_20ms("OK", 50))				// 1 секунда
				{
					NVIC_DisableIRQ(LPUART1_IRQn);					// Запрет прерываний для LPUART1
					char str2[] = "CBC:";							// подстрока, которую ищем
					char *istr = NULL;								// указатель на начало совпадения с подстрокой
					istr = strstr (LPUART1_rx_buffer, str2);		// поиск
					if ( istr == NULL)
					{
						memset(V_batt, 0x31, (sizeof(V_batt) - 1));	// Ошибка, установим VBAT=1111 (1.111 Вольт)
					}
					else
					{
						for (uint8_t i=0 ; i < 4 ; i++)
						{
							V_batt[i] = *(istr + 9 + i);			// читаем напряжение батарейки
						}
					}
					NVIC_EnableIRQ(LPUART1_IRQn);					// Разрешение прерываний для LPUART1
				}


				// информация о сети
				// АТ-команда BC66 для инженерного режима: AT+QENG=0<CR> и ответ на неё:
				// <CR><LF>+QENG: 0,1839,2,481,"35E5D4",-85,-6,-78,5,3,"4B1F",0,,0<CR><LF><CR><LF>OK<CR><LF>
				at_qeng_BC66();

				memset(RSSI_level, 0x00, sizeof(RSSI_level));

				if (LPUART1_wait_for_20ms("OK",150))				// надо ждать OK
				{
					NVIC_DisableIRQ(LPUART1_IRQn);					// Запрет прерываний для LPUART1

					// читается только значение уровня сигнала RSSI
					uint8_t comma_count = 0;						// счётчик запятых
					uint8_t k = 0;									// индекс для RSSI_level[]
					for (uint8_t i = 0 ; i < LPUART1_rx_char_cnt ; i++)
					{
						if (LPUART1_rx_buffer[i] == ',')
						{
							comma_count++;
							if (comma_count == 7)					// седьмая запятая, за ней должно быть значение RSSI
							{
								i = i + 1;
								while (LPUART1_rx_buffer[(i)] != ',')
								{
									RSSI_level[k] = LPUART1_rx_buffer[(i)];
									k++;
									i++;
								}
							}
						}
					}

					// прочитали RSSI, разрешим прерывания
					NVIC_EnableIRQ(LPUART1_IRQn);					// Разрешение прерываний для LPUART1

					state=SEND_REPORT;
					break;
				}
				else
				{
					state=ERROR_QENG;
					break;
				}

				break;

		//////////////////////////////////////////////////////////////////////////////
			case SEND_REPORT:

						// текст репорта для сервера thingspeak
						//
						memset (report_text, 0x00, sizeof(report_text));
						strcat (report_text, "GET https://api.thingspeak.com/update");
						strcat (report_text, "\?");							// вставка знака вопроса
						strcat (report_text, "api_key=");
						strcat (report_text, write_API_key);
						strcat (report_text, "&field1=");
						strcat (report_text, T_for_print);
						strcat (report_text, "&field2=");
						strcat (report_text, P_for_print);
						strcat (report_text, "&field3=");
						strcat (report_text, H_for_print);
						strcat (report_text, "&field4=");
						strcat (report_text, V_batt);
						strcat (report_text, "&field5=");
						strcat (report_text, RSSI_level);
						utoa (strlen(report_text), report_text_len, 10);	// размер репорта

						// соединимся по TCP с сервером
						if (!try_to_connect(my_server, my_port, QIOPEN_ATTEMPTS))
						{
							state = ERROR_QIOPEN;						// не подключились к серверу
							break;
						}
						if (!at_qisend(report_text_len, report_text))	// подключились к серверу, отправим данные
						{
							state = ERROR_QISEND;						// ошибка при отправке данных, закроем сокет
							break;
						}
						if (!at_qisend_CR_LF())							// отправим \r\n
						{
							state = ERROR_QISEND;						// ошибка при отправке \r\n, закроем сокет
							break;
						}

						LPUART1_rx_buffer_clear();
						// До 10 секунд ожидание подтверждения приёма от сервера: +QIURC: "recv",0,nnn
						LPUART1_wait_for_20ms("recv", 500);
						// delay(200);	// задержка, что бы сервер закрыл сокет?

						at_qiclose();									// отключение от сервера
						state=GO_TO_STOP;

						break;
			//////////////////////////////////////////////////////////////////////////

			case ERROR_BATTERY:
				quickLEDblink();
			case ERROR_PWR_ON:
				quickLEDblink();
			case ERROR_WAIT_CEREG:
				quickLEDblink();
			case ERROR_QENG:
				quickLEDblink();
			state=GO_TO_STOP;
			break;

			case ERROR_QIOPEN:
				quickLEDblink();
			case ERROR_QISEND:
				quickLEDblink();
				at_qiclose();				// отключение от сервера
			state = GO_TO_STOP;
			break;

		/////////////////////////////////////////////////////////////////////////////

		case GO_TO_STOP:
		pwr_off_BC66();						// выключим BC66
		quickLEDblink();

		//
		//----------------- Уход в Stop mode ----------------------------------------------------
		//

        // https://habr.com/ru/post/430218/
		PWR->CR &= ~(PWR_CR_PDDS);      // сброс PDDS для выбора Stop mode (если установлен, то Standby)
        PWR->CR |= PWR_CR_CWUF;         // установ CWUF для очистки флага Wakeup, или проснётся немедленно
        PWR->CR |= PWR_CR_LPSDSR;       // стабилизатор питания в low-power режим
        SCB->SCR |=  (SCB_SCR_SLEEPDEEP_Msk); // Установ бита SLEEPDEEP для выбора Stop Mode
        __disable_irq();                      // выключили прерывания; пробуждению по ним это не помешает
        __DSB();                              // завершили незавершённые операция сохранения данных
        __WFI();                              // заснули



        //
        //----------------- Проснулись, выход из Stop Mode --------------------------------------
        //

        // переинициализация рабочих частот
        // setHSIClock32M();				// Для использования HSI16/4->PLL раскомментируйте эту строку
        // setHSIClock16M();				// Для использования HSI16 раскомментируйте эту строку
        // Если две строки выше закомментированны, то используется MSI 2.097 MHz

		SystemCoreClockUpdate();
		SysTick_Config(SystemCoreClock/1000);
		__enable_irq();						// после просыпания восстановили прерывания

		state=START_DEV;
		break;

		default:
		break;

		}	// end switch(state)
	}		// end while(1)
}			// end main()
